/* Generated by Brace_UMD 0.5.0 */
!function(e, o, i, n, r) {
    var __filename, __dirname, require, define, requirejs, t = {
        e: o,
        o: e,
        requirejs: n,
        define: i,
        i: __filename || o && o.exports && o.filename || void 0,
        n: __dirname || o && o.exports && o.require('path').dirname(o.filename) || void 0,
        r: r,
        t: {
            requirejs: !0,
            define: !0,
            require: !0,
            factory: !0
        },
        d: [ 'config', 'nextTick', 'version', 'jsExtRegExp', 'isBrowser', 's', 'toUrl', 'undef', 'defined', 'specified', 'onError', 'createNode', 'load', 'exec' ],
        s: [ 'amd', 'require' ],
        f: function() {
            if (t.e && !t.define) try {
                t.define = t.e.require('amdefine')(t.e);
                for (var e in t.define) t.f[e] = t.define[e];
            } catch (e) {
                console.log('Unable to find amdefine module.', e.message);
            }
            var o = t.define || t.factory;
            o == t.define ? console.log('Using proxied amdefine definition.') : console.log('Using factory proxied from amdefine call.'), 
            o.apply(o.prototype, arguments);
        },
        c: function() {
            if (t.e && !t.requirejs) try {
                t.requirejs = t.e.require('requirejs');
                for (var e in t.requirejs) t.c[e] = t.requirejs[e];
            } catch (e) {
                console.log('Unable to find requirejs module.', e.message);
            }
            console.log('Using proxied requirejs method.');
            var o = t.requirejs || t.factory;
            o.apply(o.prototype, arguments);
        }
    };
    t.factory = t.o && function(e, o, i, n) {
        if (e && e.constructor === Array && this.e) {
            var r = e, t = dependency;
            n = n, i = i, dependency = r, e = __filename || '';
        }
        'string' != typeof e ? console.log('The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.') : o.every(function(o) {
            return o in this.o || !!console.log('The dependency', o, 'is not loaded into the factory. Skipping loading of the module', e);
        }, this) && (this.o[e] = i.apply(i.prototype, o.map(function(e, o) {
            return this.o[e];
        }, this)));
    }.bind(t);
    for (var d in t.s) t.f.__defineGetter__(t.s[d], function(e) {
        if (t.e && !t.define) try {
            t.define = t.e.require('amdefine')(t.e);
            for (var o in t.define) delete this[o], this[o] = t.define[o];
            return console.log('Using proxied amdefine method.'), t.define[e];
        } catch (e) {
            return console.log('Unable to find amdefine module.', e.message);
        }
    }.bind(null, t.s[d]));
    for (var d in t.d) t.c.__defineGetter__(t.d[d], function(e) {
        if (t.e && !t.requirejs) try {
            t.requirejs = t.e.require('requirejs');
            for (var o in t.requirejs) delete this[o], this[o] = t.requirejs[o];
            return console.log('Using proxied requirejs method.'), t.requirejs[o];
        } catch (e) {
            return console.log('Unable to find requirejs module.', e.message);
        }
    }.bind(null, t.d[d]));
    t.r.force_type && (t.r.force_type in t.t ? t[t.r.force_type] ? (console.log('Forcing use of the definition type', t.r.force_type), 
    t.requirejs = t.require = t.define = t.factory = t[t.r.force_type]) : console.log('The forced type', t.r.force_type, 'is not available.') : console.log('The forced type', t.r.force_type, 'specified as an option is not supported by Brace UMD. Supported types are', Object.keys(t.t))), 
    __dirname = __dirname || t.n, __filename = __filename || t.i, define = t.define || t.f, 
    requirejs = t.requirejs || t.c, require = t.e && t.e.require || requirejs;
;



define('serializer',["require"], function(require) {

	return function(msg, indent_string, previous_indent, level) {
	  // The Object to text parsing engine. this function will print any Object passed to it (including function text), in the most litteral way possible.
	  // It can be recursively called within itself and also accepts modifiers to alter output. The indent_string argument contains how the
	  // subsequent Object levels will seperate from the left margin. The indent_string is multiplied by the Object level when looping through
	  // adding the indent_string to the previous_indent (which is expanding), every time an Object is parsed while already parsing an Object
	  // (calling _serialize inside _serialize). this member can not be called outside this script with out breaking the the overlying
	  // functionality of this script. The previous_indent argument/parameter will be placed at the start of each new object in the output (used internally).

	  // Store text adds platform dependant color syntax the strings passed in a parameters. The stings are stored internnally in the store text
	  // instance until formated or plain properties are accessed (it uses a getter).
//	  this.bufferize.theme = this.theme + "_level_" + this.level
//	  this.bufferize.use_color = this.use_color
//	  this.bufferize.character_limit = this.character_limit

	  // A simple way to stop Object parsing when the output becomes too large. The actuall size of the interanll string is maintained by the color addon.
	  if ( this.plain.length >= this.character_limit )
		 return

	  indent_string = typeof indent_string === "string" && indent_string || (this.append_string("denote_space.toString", ) + this.append_string("denote_space.toString", ))
	  level = parseInt(level) || 0
	  previous_indent = previous_indent && previous_indent.toString() || ""

	  var compress_separator, line_separator = ""
	  if ( this.compress_level > 3 ) {
		 // There will be no indents, spaces or lines at the highest compression level.

		 indent_string = ""
		 compress_separator = ""
		 line_separator = ""
	  }
	  else if ( this.compress_level === 3 ) {
		 // No indents and lines are spaces as well.
		 indent_string = ""
		 compress_separator = this.style_map[this.platform].denote_space.toString()
		 line_separator = this.style_map[this.platform].denote_space.toString()
	  }
	  else if ( this.compress_level === 2 ) {

		 compress_separator = this.style_map[this.platform].denote_space.toString()
		 line_separator = this.style_map[this.platform].denote_line.toString()
	  }
	  else {
		 // The lowest compression settings are the same as the sencond most above (two), except some ligic in the Object serializer below.

		 compress_separator = this.style_map[this.platform].denote_space.toString()
		 line_separator = this.style_map[this.platform].denote_line.toString()
	  }
	  if ( msg instanceof (this.parent || function(){}) ) {

		this._serialize(msg.toString())
	  }
	  else if ( msg === null ) {

		this.append_string("null", "null")
	  }
	  else if ( typeof msg === "boolean" ) {

		this.append_string("boolean", msg.toString())
	  }
	  else if ( msg !== msg ) { // NaN is the only js object which is not equal to itself

		this.append_string("not_a_number", "NaN")
	  }
	  else if ( msg instanceof Error ) {

		var stack_string = msg.stack.split("\n")
		this.append_string("namespace", stack_string.splice(0,1) + line_separator)
		this.append_string("function_body", stack_string.join(line_separator))
	  }
	  else if ( typeof msg === "undefined" ) {

		this.append_string("undefined", "undefined")
	  }
	  else if ( typeof Buffer !== "undefined" && msg.__proto__ && msg.__proto__.constructor === Buffer ) {

		this._serialize(msg.toString())
	  }
	  else if ( typeof msg === "object" || typeof msg === "function" ) {
		 // Here is the man object parsing function. It will print all of the data from a Object including functions and prototypes.
		 var key_grab = !this.enumerate_all && Object.keys || Object.getOwnPropertyNames
		 this._is_from_object = true
		 var keys = key_grab(msg), is_primitive_object = false
		 this._cache[level] = this._cache[level] || []
		 // There is no need to put primitive Objects into the cache sense they are never circular dependencies to another one.
		 if ( typeof msg === "object" && typeof msg.valueOf === "function" && msg.valueOf() !== msg ) {
			is_primitive_object = true
		 } else {
			this._cache[level].push(msg)
		 }

		 for ( var n = 0; n < level; n++ ) {
			for ( var x = 0; x < this._cache[n].length; x++ ) {
			  if ( typeof msg === "object" && msg === this._cache[n][x] ) {
				 // Circular reference found, discard object processing

				 var circ_text = "[[Circular duplicate of "
				 var obj_qualifier = key_grab(this._cache[n][x])
				 obj_qualifier.unshift("")
				 obj_qualifier = obj_qualifier.join(" "+(this._cache[n-1]&&this._cache[n-1][x]||"<-"))
				 if ( circ_text.length+obj_qualifier.length > 75 )
				 obj_qualifier = obj_qualifier.substr(0, 71-circ_text.length) + ".."

				 this.append_string("namespace", circ_text)
				 this.append_string("scope_container", "{"+compress_separator)
				 this.append_string("function_body", obj_qualifier)
				 this.append_string("scope_container", compress_separator+"}")
				 this.append_string("namespace", "]]")
				 return
			  }
			}
		 }
		 var is_array = msg.constructor === Array
		 if ( typeof msg === "function" ) {

			// This regex will strip out the function: declaration, name, parameters and body. The body is only parsed for indentation and will use the string
			// provided as indent string.
			var f_str = msg.toString().match(/function(?:\ |\n)*(\S*)\(([^\)]*)\)(?:\ |\n)*\{((?:.|\n)*)\}(?:\ |\n)*/i) || []
			var f_name = f_str[1] || ""
			var f_parameter = f_str[2] || ""
			var f_body = f_str[3] || ""

			this.append_string("namespace", "function ")
			this.append_string("string", f_name)
			var param = f_parameter.split(",")
			// The parameter list is striped from the function text which will produce an Array containing an empty string if no parameters are used in the
			// Function. E.g. function(cool) -> ["cool"], function() -> [""]. The parenthisis will only have space (compress_separator), if parameters are
			// used in the function. Note: the compress_separator adjusts pending the this.compress_level.
			this.append_string("scope_container", "(" + (param[0] && compress_separator || ""))

			// Make the parameter string fro the list
			param.forEach(function(val) {
			  this.append_string("variable", val)
			  this.append_string("comma", ",")
			}, this)

			// Remove the last comma from the parameter string
			this.remove_call(-1)
			this.append_string("scope_container", (param[0] && compress_separator || "") + ")" + compress_separator)
			this.append_string("scope_container", "{" + compress_separator)

			if ( !this.truncate_function ) {

			  // Replace the first line with a new line if contains text before a newline so that it is always printing with a newline after
			  // the function declaration.
			  var body_indent = previous_indent + indent_string, compress_level = this.compress_level
			  // This needs to be what the actual newline is for the platform because function text must maintain newlines to function properly.
			  var style = this.style_map[this.platform]
			  // Replace every newline in the function string with current indentation string the text and then the desired newline (this.bufferize.denote_line).
			  var has_end_new_line = true
			  if ( ! /\n/.test(f_body) )
				 f_body = "\n" + f_body + "\n"
			  f_body.replace(/(.*)(\n+)/g, function() {
				 // If line was only white space or newlines than it can be removed from processing if the compress level is high enough.

				 var has_ascii = arguments[1].replace(/\s*/g, "")
				 if ( compress_level >= 4 && !has_ascii )
					return ""
				 // More than two newlines will be replace with two newlines when compression levels are two or three
				 if ( ( compress_level === 2 || compress_level === 3) && /\n{2,}/.test(arguments[2]) )
					arguments[2] = "\n\n"

				 // The indent string should not be used if the line contains no ascii characters (this avoids indent strings where there
				 // only is whotespace in a balck line.
				 if ( has_ascii  )
					bufferize.indent(body_indent)

				 has_end_new_line = false
				 var indent = style.denote_line.toString()
				 if ( compress_level < 4 ) {
					var newline = arguments[2].match(/\n/g)
					newline.pop()
					newline.forEach(function() {
					  has_end_new_line = true
					  indent += style.denote_line.toString()
					})
				 }
				 bufferize.function_body(arguments[1]||"")
				 bufferize.indent(indent)
			  }) // End of f_body.replace function
			  if ( !has_end_new_line )
				 this.remove_call(-1)
			} // End of if  truncate_function
			else {
			  this.append_string("function_body", compress_separator + "..." + compress_separator)
			}
		 }
		 else {
			this.append_string("scope_container", is_array&&"["||"{" + (this.compress_level < 3 && this.style_map[this.platform].denote_space.toString() || ""))
		 }

		 var cnt = 1
		 if ( !keys.length ) {

			if ( msg.__proto__ && typeof msg.__proto__ === "object" && key_grab(msg.__proto__).length ) {

				 this.append_string("indent", line_separator + previous_indent + indent_string)
				 this.append_string("namespace", "__proto__")
				 this.append_string("colon", ":" + compress_separator)
				 this._serialize(msg.__proto__, indent_string, previous_indent + indent_string, level+1)

			  if ( is_primitive_object ) {

				 this.append_string("indent", line_separator + previous_indent + indent_string)
				 this.append_string("namespace", "[[PrimitiveValue]]")
				 this.append_string("colon", ":" + compress_separator)
				 this._serialize(msg.valueOf(), indent_string, previous_indent + indent_string, level+1)
				 this.append_string("comma", "," + compress_separator)
				 // This happens when the Object is a primitive value with Object keys set (new String("abc"). The length property will not be added
				 // sense it is a property of the primitive value (not the Object). Therefore the length property is added as a design choice.
				 if ( typeof msg.length !== "undefined" ) {
					this.append_string("indent", line_separator + previous_indent + indent_string)
					this.append_string("string", "length")
					this.append_string("colon", ":" + compress_separator)
					this._serialize(msg.length, indent_string, previous_indent + indent_string, level+1)
					this.append_string("comma", "," + compress_separator)
				 }
				 this.remove_call(-1)
			  }
			}
			this.append_string("indent", line_separator + previous_indent)
			this.append_string("scope_container", is_array&&"]"||"}")
			this.append_string("comma", "," + compress_separator)
		 }

		 // Object.keys are used here to loop instead of the in operator so that the __proto__ keys are not looped over sense they were handled above.
		 for ( var x = 0; x < keys.length; x++ ) {
			var o = keys[x]

			if ( this.plain.length >= this.character_limit )
			  return

			// Add the indent string to the begining of the parsing loop or if the item is an Object. this is the primary formating controler.
			var is_property_based = !!(typeof msg[o] === "object" && msg[o] !== null && msg[o] !== undefined && key_grab(msg[o]).length )

			if ( cnt !== 1 && this.compress_level < 2 )
			  this.append_string("indent", line_separator + previous_indent + indent_string)
			if ( cnt === 1 || is_property_based ) {
			  this.append_string("indent", line_separator + previous_indent + indent_string)
			  if ( cnt === 1 && typeof msg.valueOf === "function" && msg.valueOf() !== msg ) {
				 this.append_string("namespace", "[[PrimitiveValue]]")
				 this.append_string("colon", ":" + compress_separator)
				 this._serialize(msg.valueOf(), indent_string, previous_indent + indent_string, level+1)
				 this.append_string("comma", "," + line_separator)
				 this.append_string("indent", compress_separator)
			  }
			  // If the item has a primitive value than it will not be equal to it self and therefor the primitive value should be displayed.
			}
			if ( !is_array ) {
			  // _serialize is used here to format the qualifiers strings if this loop is parsing an object. This should only add numbers and strings as this
			  // is the only type of qualifiers ecma allows (for now:).
			  this._serialize(o)
			  this.append_string("colon", ":" + compress_separator) // Object separator makes it more human readable by adding space. This changes with the compress_level.
			}
			// recursively call this function to parse the object. The indent_string is added to the begining to nest the output. It is important to
			// use level+1 here instead of assignment operators like level++ or ++level so that it is only passed in with an increment ans this
			// function call keeps the value of level. this way each call to _serialize uses a level incremented by one from the calling _serialize.

			// Here parses nested Objects from within Objects and stops at the level specified in the depth_limit setting. this is good for super massive
			// Objects like browser self, window, jQuery and document or for other practical use. Object serialization will stop when the specified depth
			// is reached in an Object which contains more Object to serialize. The Object serialization will be replaced with a String decribing the Object.
			// Any non-literal Objects will be printed on the last depth parsing level (which is what the !is_property_based test is for).
			if ( level < this.depth_limit-1 || !is_property_based ) {
			  this._serialize(msg[o], indent_string, previous_indent + indent_string, level+1)
			} else {
			  var len = key_grab(msg[o]).length
			  this.append_string("namespace", Print().add("[[", is_array && "Array" || "Object", " with ", len, " propert")
			  .add(len === 1 && "y" || "ies", "]]")
			  )
			}

			this.append_string("comma", "," + compress_separator)
			// These two positions of the loop separate the ___proto__ and property values of the Object which is being parsed.
			if ( cnt === keys.length ) {

			  // This happens when the Object is a primitive value with Object keys set (new String("abc"). The length property will not be added
			  // sense it is a property of the primitive value (not the Object). Therefore the length property is added as a design choice.
			  if ( is_primitive_object && typeof msg.length !== "undefined" ) {

				 this.append_string("indent", line_separator + previous_indent + indent_string)
				 this.append_string("string", "length")
				 this.append_string("colon", ":" + compress_separator)
				 this._serialize(msg.length, indent_string, previous_indent + indent_string, level+1)
				 this.append_string("comma", "," + compress_separator)
			  }
			  // Remove the last comma from the item list and add the newline and indentation.
			  this.remove_call(-1)

			  if ( msg.__proto__ && typeof msg.__proto__ === "object" && Object.keys(msg.__proto__).length ) {

				 this.append_string("comma", "," + compress_separator)
				 this.append_string("indent", line_separator + previous_indent + indent_string)
				 this.append_string("namespace", "__proto__")
				 this.append_string("colon", ":" + compress_separator)
				 this._serialize(msg.__proto__, indent_string, previous_indent + indent_string, level+1)
			  }
			  this.append_string("indent", line_separator + previous_indent)
			  this.append_string("scope_container", is_array&&"]"||"}")
			  this.append_string("comma", "," + compress_separator)
			}
			cnt++
		 }

		 // Remove the last comma from the parsing output. It is the last thing to be stored so a simple call to remove the last call will surfice.
		 this.remove_call(-1)
		 // An Object which is being parsed will always have a level. It is set as soon as Object parsing begins.
		 this._is_from_object = !!level
	  }
	  else if ( typeof msg === "number" ) {

		this.append_string("number", msg.toString())
	  }
	  else if ( typeof msg === "string" ) {
		// The quotes are only added if this _serialize call was called from another _serialize call. Otherwise all calls with strings would have quotes.

		 if ( this._is_from_object ) {
			this.append_string("quote", this.denote_quoting)
			this.append_string("string", msg)
			this.append_string("quote", this.denote_quoting)
		 } else {
			this.append_string("string", msg)
		 }
	  }
	  else {
		 // Nothing should be able to get here as all of the types of str should be caught above.
		 this.append_string("namespace", msg.toString())
	  }
	  return this.style_map[this.platform]
	}

})

;
/*
Copyright (c) 2017 Robert Edward Steckroth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

  Brace Prototype is a nodejs and browser script which returns a method that is used within prototypes to control properties with the chain.

 Author: Robert Edward Steckroth II, Bustout, <RobertSteckroth@gmail.com>
*/



define('brace_prototype/brace_prototype',[], function() {

	return function(proto) {

		if ( typeof proto !== "object" )
			// !!console.log should return false in all platforms so this simply returns the argument back.
			return !!console.warn("Brace prototype must be passed an Object to assign additional members.") || proto

		// It is important for _list to be decoupled from the passed in prototype Object so that prototypes are not updated when the (add/remove)_qualifier
		// members are used.
		var _list = {}
		for ( var n in proto )
			_list[n] = proto[n]

		var _remove = function(qualifier) {
		// Reset all of the values in the prototype of the Object which contains this member to the default values. The default value is the value 
		// contained in the prototype of the instance. The property will not be changed if the Object does not have a prototype or if the property 
		// is not part of the prototype.

			if ( this.hasOwnProperty(qualifier) ) {
				// This block will check to ensure that the prototype property exists and it is a owned property. The property will not be removed if the
				// corresponding qualifier was deleted in the prototype. Otherwise, it should be expected that any of the properties in the maintained _list of
				// parameters are not deleted (remove_qualifier should be used instead.

			   // The entire chain needs to be checked with a loop if Object.getPrototypeOf does not exist (i.g. versions of Opera below 10.50).
			   if ( typeof Object.getPrototypeOf === "function" )
					return !!Object.getPrototypeOf(this)[qualifier] && delete this[qualifier] || true
			   else
					// Find out if the property is located within the prototypal chain with this loop.
					for ( var chain = this.__proto__; chain; chain = chain.__proto__)
					  // Only delete the property if it is contained within the prototypal chain.
						if ( qualifier in chain )
							// The delete return value is not reliable :(
							return delete this[qualifier] || true
			}

			return false

		}

		proto.clear = function() {
			// Passing in string parameters to this member will reset only the members of the instance. All of the members of the instance will be 
			// reset if no parameters are passed to the call to this member.

			// Loop through all of the properties is no strings were passed in.
			if ( !arguments.length )
				for ( var n in _list )
					_remove.call(this, n)

			 // Loop through only the string arguments passed in.
			 for ( var x in arguments )
				 if ( arguments[x] in _list )
					 _remove.call(this, arguments[x])
				 else
					 console.log("The qualifier", arguments[x], "was passed to a brace prototype instance which does not have it listed.",
									 "You should either: insert the qualifier to the constructor Object parameter or add the qualifier with the add_qualifier member.")
		}
		
		proto.extend = function(obj) {

			// This will extend this Object by setting the property descriptors which will include much of the Object information. getOwnPropertyNames will
			// loop through all of the Object properties (including non-enumerable ones).
			Object.getOwnPropertyNames(obj).forEach(function(key) {
				var desc = Object.getOwnPropertyDescriptor(obj, key)
				Object.defineProperty(this, key, desc)
			}, this)

			return this 
		}

		proto.add_qualifier = function(qualifier) {

			_list[qualifier] = _list[qualifier] || null
			proto[qualifier] = proto[qualifier] || null
		}

		proto.remove_qualifier = function(qualifier) {

			// This will prevent it from being removed from any of these members.
			delete _list[qualifier]
		}

		proto.list = function() {

			return _list
		}

		return proto
	}


})
;
define('brace_prototype', ['brace_prototype/brace_prototype'], function (main) { return main; });




define('proto_object',["require", "./serializer", "brace_prototype"], function(require, serializer) {

	var proto = require("brace_prototype")	

	var p = proto({

	  use_style: true,
	  use_title_stamp: function() { return new Date() },
	  log_title: "",
	  theme: "light",
	  // The compression level of the Object serializations. Higher numbers mean more sparce formating. Level one removes all white space and new lines from the Object.
	  compress_level: 2,
	  use_title: true,
	  indentation_string: "   ",
	  // TODO: Add controls so the JSON.parse will evaluate correctly
	  //parsing false,
	  //platform: typeof module === "object" && typeof process === "object" && typeof process.env === "object" && "terminal" || "browser",
	  platform: "terminal",
	  // This will prevent Object serialization to traverse to a deeper level with Objects (it avoids call stack max-out conditions).
	  depth_limit: 130,
	  // The logging storage and serializations will be cut short and trucncated to this character_limit.
	  character_limit: Math.pow(2,28),
	  truncate_function: false,
	  // Objects that are built-in to javascript have the enumerable flag set to false. In order to parse these Objects (and other Objects), the
	  // enumerate_all flag needs to be set.
	  enumerate_all: false,
	  denote_quoting: "\"",
	  // Note: use_level is contained one level up in the chain and should stay that way.
	  // This is the level which needs to be in the range set to use_level. All serializations, logging and storage will be ignored (disabled), if
	  // the level is not a match to the use_level.
	  level: 1,
	  // TODO: this should have an option to keep the same as the level.
	  // This is used to set the level of any messages which are logged internally in the p library.
	  internal_level: 2,
	})

	return p.extend({
		_serializer: serializer,
		_descoped_use_level_setter: function(value) {
		  // This setter accepts strings, numbers and Arrays. Arrays should be in pairs denoting ranges. Two Array values of the same value need to be set
		  // to denote a single value. E.g. [1, 1, 4, 6] denotes a level of either 1 or on/between 4 and 6. Strings can be passed in lieu of Array pairs for
		  // more human friendly syntax. When strings are passed in: ranges are two numbers separated with a dash and single value levels are separated
		  // with commas. E.g. use_level = "1,4-6" denotes a level of either 1 or on/between 4 and 6 like the example above. White space is ignored and strings
		  // are parsed as numbers in any case (Array or String). The value of use_level will be set to [-Infinity, Infinity] (which will match all levels),
		  // if an empty string or the string "all" is set. Note: The only way to use negative numbers is to passed in Array pairs.

		  if ( value === "all" || value === "" )
			 return this._use_level = [-Infinity, Infinity]

		  if ( Object.prototype.toString.call(value) === "[object Array]" ) {
			 // Arrays can only be passed in as pairs of ranges (which is what non-Array values set to use_level are converted to.

			 if ( value.length % 2 )
				value.pop()
		  } else {
			 // All proccessing is utilized with Arrays in this function.
			 value = [value]
		  }

		  value = value.join("-")
		  this._use_level = parsed = []

		  // Split the commas and dashes into a uniform parsable Array.
		  value.toString().replace(/\ +/g, "").replace(/\-\-([^\-]{1})/g, "-minus$1").replace(/^\-/, "minus").split(",").forEach(function(val) {

			 if ( !val )
				return

			 var range = val.split("-")
			 if ( range.length < 2 )
				range.push(range[0])

			 for ( var x = 0; x < range.length; x+=2 ) {

				var first_is_negative = /minus/.test(range[0]), second_is_negative = /minus/.test(range[1])
				if ( /Infinity/.test(range[x]) )
				  range[x] = Infinity
				else
				  range[x] = parseInt(range[x].replace(/minus/, ""))

				if ( /Infinity/.test(range[x]) )
				  range[x+1] = Infinity
				else
				  range[x+1] = parseInt(range[x+1].replace(/minus/, ""))

				if ( range[x] !== range[x] || range[x+1] !== range[x+1] )
				  return new this.parent({level: this.internal_level}).log("The value set to use_level can not be parsed as an integer:", range)

				// If the string contained a negitve number (the range dash is already compensated for).
				if ( first_is_negative )
				  range[x] *= -1
				if ( second_is_negative )
				  range[x+1] *= -1

			 }
			 parsed = parsed.concat(range)
		  })
		  this._use_level = parsed
		},

		// Dont delete me! This is expected to always exist internally.
		_use_level: [-Infinity, Infinity], // The default use_level option will initially be altered by this getter until the parent level prototype chain
		// This setter is used by both this level and the setter at the level below (child prototype), so that the parent can be deleted without loosing the inherent
		// functionality of the use_level property (which parses as a string and re-sets its value).
		set use_level(value) { 
			Print._descoped_use_level_setter.call(this, value) 
		},
		get use_level() {
		  // Always used from this prototype level. The next_level (__proto__), also uses the same _use_level property. This is to the setter functionality
		  // while still providing multi-layered configurations.

		  return this._use_level
		},
		toColorString: function() {
		  // These two members return strings so no chaining mechanism is uitlized (like a getter returning a function which returns the instance). They
		  // do accept parameters to serialize just like all other printing commands. Note: this method is very fast (especially without arguments), as
		  // it only returns an Object property.

		  var uses_apply = this.style_map[this.platform].format.length >= 3
		  return this._print_command(this._last_command || "space").apply(this, arguments).formated + (uses_apply &&
				this.apply_arguments.length && this.apply_arguments.join(" ") || "")
		},
		toString: function() {
		  // These two members return strings so no chaining mechanism is uitlized (like a getter returning a function which returns the instance). They
		  // do accept parameters to serialize just like all other printing commands. Note: this method is very fast (especially without arguments), as
		  // it only returns an Object property.

		  return this._print_command(this._last_command || "space").apply(this, arguments).plain
		},
		set_option: function() {
		  // The other way of setting the options which resturns this to maintain call chains. Objects, p() instances and Strings can be passed into
		  // the set_option method. Any Strings will be used to set the log_title options. Objects passed in after other Objects will overide the previous
		  // Object data set so that the last Object in the parameter list is has the highest priority.

		  var print = ((this._is_chained || this._from_constructor) && this) || new this.parent(this)
		  // The is_chained property tells any printing commands to create a new instance or use the existing.
		  if ( !this._from_constructor )
			 print._is_chained = true
		  for ( var i = 0; i < arguments.length; i++ ) {

			 // Log titles can be passed in as strings (this is the only allowable non-Object parameter.
			 if ( typeof arguments[i] === "string" )
				arguments[i] = {log_title: arguments[i]}
			 if ( arguments[i] instanceof this.parent ) {
				arguments[i] = arguments[i].list()
			}

			 var mutable = print.list()

			 for ( var n in arguments[i] ) {
				if ( n in mutable || n === "use_level" ) {
				  if ( this._from_constructor )
					 p[n] = arguments[i][n]
				  else
					 p[n] = arguments[i][n]
				} else {
				  this.constuctor({use_level: "", level: print.internal_level})
					 .sp("Option", n, "is not a brackit print option. Use ._mutable_options to see all user configurable options:")
					 .line(print.list()).log()
				}
			 }
		  }
		  this._from_constructor = false
		  return print
		},
		new_copy: function() {
			// This is how bracket print transfers options to other Print instances. It is best to make a single print instance and then and pass the copy 
			// into another Print copy. It is in this way that all of the p objects contain inherit settings and then can have the options changed 
			// individually if nessesary. The function parameters work the same way as the set_option member and p constructor.
			return new this.parent(this, arguments)
		},
		get clear() {
			// Remove all of the text storage from the current p instance.

			return (function() {
			  // Splices all text storage from the beginning of the bufferize instance.
			  this.remove_call(0)
			  return this
			}).bind(this)
		},
		//----------------------------------------------------------------------------
		get sp() {

		 return this._print_command("space")
		},
		get space() {

		 return this._print_command("space")
		},
		get tab() {

		 return this._print_command("tab")
		},
		get line() {

		 return this._print_command("line")
		},
		get add() {

		 return this._print_command("add")
		},
		// ---------------------------------------------------------------------------
		// Here are all of the print commands which ease string formation.
		_print_command: function(call_name) {

		 // This is used internally whenever a input member is called. The _chain is a pre-cursor for the _serialize memeber which converts Objects to text.
		 // this is passed into the p constructor so that the current settings will be saved.
		 var print = this._is_chained && this || new this.parent(this)
		 print._is_chained = true
		 print._last_command = call_name

		 return (function() {

			// No need to process if no arguments were passed in. As long as the _print_command returns a function which returns the instance.
			if ( !arguments.length )
			 return this
			for ( var x = 0; x < this.use_level.length; x += 2 )
			  if ( parseInt(this.level) >= this.use_level[x] && parseInt(this.level) <= this.use_level[x+1] ) {
				 return this._chain.apply(this, arguments)
			 }
			 return this

		 }).bind(print)
		},
		get _chain() {
		 // This is the main printing member.
		 return function() {
			// This happens when the platform option is changed after the constructing (first), print command is called.
			if ( this._old_platform.toLowerCase() !== this.platform.toLowerCase() ) {
			  this._old_platform = this.platform
			  // Every instance of this needs to have its own intance of the bufferize prototype so that text can be stored using the internal buffer.
			  //this.style_map[this.platform] = new this.parent[this.platform.toLowerCase()]
			}

			var indentation = this.indentation_string.replace(/\t/g, this.style_map[this.platform].denote_tab).replace(/\n/g, this.style_map[this.platform].denote_line).replace(/\ /g, this.style_map[this.platform].denote_space)

			this._cache = []
			for ( var i = 0; i < arguments.length; i++ ) {

			  if ( this.plain.length && typeof this.style_map[this.platform]["denote_"+this._last_command] !== "undefined" ) {
				 // Add the last separator relating to the previous printing command called
				 this.plain += this.style_map[this.platform]["denote_"+this._last_command]
				 this.formated += this.style_map[this.platform]["denote_"+this._last_command]
			  }

			  this._serializer(arguments[i], indentation)
			  //this.style_map[this.platform].formated += this.style_map[this.platform].closing_tag||""
			  // Empty the Object processing cache which is used to ensure Circular object references do not occur within printing.
			  this._cache = []
			}
			return this
		 }
		},
		get log() {

		 // this is passed into the this (p), contstuctor so that the current settings will be saved.
		 var print = this._is_chained && this || new this.parent(this)
		 print._is_chained = true
		 return (function() {
			var in_range = false
			for ( var x = 0; x < this.use_level.length; x += 2 )
			  if ( parseInt(this.level) >= this.use_level[x] && parseInt(this.level) <= this.use_level[x+1] ) {
				  in_range = true
				  break
			 }

		 if ( !in_range )
			 return this

			if ( arguments.length > 0 ) {
			  // Call the last command used before this log again.
			  if ( this[this._last_command] ) {
				this[this._last_command].apply(this, arguments)
			  }
			  else {
				 this.space.apply(this, arguments)
			  }
			}

			if ( this.formated ) {

			  // Append the logging title if there is one set and then turn the entire output string
			  // into an array to pass with the console.log.apply
			  var style = this.style_map[this.platform]
			  //color_copy = new this.parent[this.platform.toLowerCase()]
			  var theme = this.theme + "_level_" + this.level
			  var title = ""
			  if ( this.use_title && (this.log_title || this.use_title_stamp) )
				  title = "[" + (typeof this.use_title_stamp === "function" && this.use_title_stamp() || "") + (this.use_title_stamp && this.log_title&&" - "||"") + this.log_title + "] "

			  this.append_string("title", title)

			  var c_args = [(this.formated||this.plain)+this.formated]
			  // append any css arguments if the browser segment of our custom bufferize object was utilized
		  	  var uses_apply = this.style_map[this.platform].format.length >= 3
			  if ( uses_apply )
				 c_args = c_args.concat(this.apply_arguments).concat(this.apply_arguments)

			  console.log.apply(console, c_args)
			}
			return this
		 }).bind(print)
		},
		get log_false() {
		 // These will return true/false regardless of the debuffing state as well.

		 return (function() {
			this.log.apply(this, arguments)
			return false
		 }).bind(this)
		},
		get log_true() {
		 // These will return true/false regardless of the debuffing state as well.

		 return (function() {
			this.log.apply(this, arguments)
			return true
		 }).bind(this)
		},
		get log_null() {
		 // These will return true/false regardless of the debuffing state as well.

		 return (function() {
			this.log.apply(this, arguments)
			return null
		 }).bind(this)
		},
		get log_empty() {
		 // These will return true/false regardless of the debuffing state as well.

		 return (function() {
			this.log.apply(this, arguments)
			return ""
		 }).bind(this)
		},

	})

})	
;



define('style_map',["require"], function(require) {

	return {

		browser: {

			denote_line: "\n",
			denote_tab: "\t;",
			denote_space: " ",
			denote_add: "",
			use_theme: "html",
			format: function(style_value, str, apply_args) {
				apply_args.push(style_value)
				return "%c"+str
			},
		},
		html: {

			denote_line: "<br>",
			denote_tab: "&#09;",
			denote_space: "&nbsp;",
			denote_add: "",
			format: function(color_value, str) {
				return "<span style='"+color_value+";'>"+str+"</span>"
			},
			theme: {

				light_level_1: {
					quote: "color: #454343;",
					number: "color: green",
					string: "color: #b91db3",
					function_body: "color: #656565",
					not_a_number: "color: #249e93",
					null: "color: #249e93",
					boolean: "color: red",
					comma: "color: #323232",
					undefined: "color: #f4d400",
					scope_container: "color: #286f4f",
					colon: "color: #363533",
					namespace: "color: #690900", // E.g. .__proto__ [[PrimitiveValue}}
					indent: "color: #c2bab8",
					title: "color: #0a0a0a",
					variable: "color: #4a6a27",

				},
				light_level_2: {
					quote: "color: #454343; font-weight: bold;",
					number: "color: green; font-weight: bold",
					string: "color: #b91db3; font-weight: bold",
					function_body: "color: #656565; font-weight: bold",
					not_a_number: "color: #249e93; font-weight: bold",
					null: "color: #249e93; font-weight: bold",
					boolean: "color: red; font-weight: bold",
					comma: "color: #323232; font-weight: bold",
					undefined: "color: #f4d400; font-weight: bold",
					scope_container: "color: #286f4f; font-weight: bold",
					colon: "color: #363533; font-weight: bold",
					namespace: "color: #690900; font-weight: bold", // E.g. .__proto__ [[PrimitiveValue}}
					indent: "color: #c2bab8; font-weight: bold",
					title: "color: #0a0a0a; font-weight: bold",
					variable: "color: #4a6a27; font-weight: bold",

				},
				dark_level_1: {
					quote: "color: #d2d2d2",
					number: "color: green",
					string: "color: #e9e9e9",
					function_body: "color: #a7a7a7",
					not_a_number: "color: yellow",
					null: "color: #5bc3ba; font-weight: bold",
					boolean: "color: red",
					comma: "color: #787878",
					undefined: "color: #e9d234",
					scope_container: "color: #80ab96",
					colon: "color: #dfd9b3",
					namespace: "color: #e05c50", // E.g. .__proto__ [[PrimitiveValue}}
					indent: "color: #373332",
					title: "color: #f2f2f2; font-weight: bold",
					variable: "color: #baeb83",

				},
				dark_level_2: {
					quote: "color: #d2d2d2; font-weight: bold",
					number: "color: green; font-weight: bold",
					string: "color: #e9e9e9; font-weight: bold",
					function_body: "color: #a7a7a7; font-weight: bold",
					not_a_number: "color: yellow; font-weight: bold",
					null: "color: #5bc3ba; font-weight: bold; font-weight: bold",
					boolean: "color: red; font-weight: bold",
					comma: "color: #787878; font-weight: bold",
					undefined: "color: #e9d234; font-weight: bold",
					scope_container: "color: #80ab96; font-weight: bold",
					colon: "color: #dfd9b3; font-weight: bold",
					namespace: "color: #e05c50; font-weight: bold", // E.g. .__proto__ [[PrimitiveValue}}
					indent: "color: #373332; font-weight: bold",
					title: "color: #f2f2f2; font-weight: bold",
					variable: "color: #baeb83; font-weight: bold",

				},
			},
		 },
		 terminal: {

			denote_line: "\n",
			denote_tab: "\t;",
			denote_space: " ",
			denote_add: "",
			format: function(style_value, val) {
				return style_value+val
			},
			theme: {
				light_level_1: {
					quote: "\033[0;30m",
					number: "\033[0;32m",
					string: "\033[0;35m",
					function_body: "\033[0;30m",
					not_a_number: "\033[0;33m",
					null: "\033[0;36m",
					boolean: "\033[0;31m",
					comma: "\033[0;30m",
					undefined: "\033[0;32m",
					scope_container: "\033[0;36m",
					colon: "\033[0;30m",
					namespace: "\033[0;31m", // e.g. .__proto__ [[primitivevalue}
					indent: "\033[0;37m",
					title: "\033[0;35m",
					variable: "\033[0;34m",

				},
				light_level_2: {
					quote: "\033[1;30m",
					number: "\033[1;32m",
					string: "\033[1;35m",
					function_body: "\033[1;30m",
					not_a_number: "\033[1;33m",
					null: "\033[1;36m",
					boolean: "\033[1;31m",
					comma: "\033[1;30m",
					undefined: "\033[1;32m",
					scope_container: "\033[1;36m",
					colon: "\033[1;30m",
					namespace: "\033[0;31m", // e.g. .__proto__ [[primitivevalue}
					indent: "\033[1;37m",
					title: "\033[1;32m",
					variable: "\033[1;34m",

				},
				dark_level_1: {
					quote: "\033[0;37m",
					number: "\033[0;32m",
					string: "\033[0;35m",
					function_body: "\033[0;30m",
					not_a_number: "\033[0;33m",
					null: "\033[0;36m",
					boolean: "\033[0;31m",
					comma: "\033[0;37m",
					undefined: "\033[0;32m",
					scope_container: "\033[0;36m",
					colon: "\033[0;37m",
					namespace: "\033[0;31m", // E.g. .__proto__ [[primitivevalue}}
					indent: "\033[0;30m", // If an indentation_string is provided it will be colorized as this.
					title: "\033[0;37m",
					variable: "\033[0;34m", // E.g. function( num, opt ) { .
													//                ^^^  ^^^
				},
				dark_level_2: {
					quote: "\033[1;37m",
					number: "\033[1;32m",
					string: "\033[1;35m",
					function_body: "\033[1;30m",
					not_a_number: "\033[1;33m",
					null: "\033[1;36m",
					boolean: "\033[1;31m",
					comma: "\033[0;37m",
					undefined: "\033[1;32m",
					scope_container: "\033[1;36m",
					colon: "\033[1;37m",
					namespace: "\033[1;31m", // E.g. .__proto__ [[primitivevalue}}
					indent: "\033[1;30m", // If an indentation_string is provided it will be colorized as this.
					title: "\033[1;37m",
					variable: "\033[1;34m", // E.g. function( num, opt ) { .
													//                ^^^  ^^^
				},
			},
		}

	}

})
;
/*
  Brackit print is a printing and logging tool for javascript engines which supplies literal ECMA Object serialization.
Copyright (C) 2017  Robert Edward Steckroth II <RobertSteckroth@gmail.com>

 this file is a part of Brackit print

 Brackit Print is free software: you can redistribute it and/or modify it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Brackit print is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

// Author: Robert Edward Steckroth, Bustout, <RobertSteckroth@gmail.com>

// This will be striped out by the requirejs optimizer.


define('bracket_print',["require", "./proto_object", "./style_map"], function(require, obj, style_map) {
	
	var Print = function() {
	  // This accepts all of the parameters as set_option does. 

		// This will call the constructor with the same arguments as initially passed as a new instance if it was not done so to ensure a new instance is
		// always created when invoking the constructor.
	  if ( !(this instanceof Print) ) {
		 var call_instance = Print
		 for ( var x = 0; x < arguments.length; x++ )
			call_instance = call_instance.bind(call_instance.prototype, arguments[x])
		 return new call_instance()
	  }

	  var copy_setting = function(setting) {
		 // Copy the settings Object passed in to the prototype of the current instance. This effectively copies all of the necessary options to the current
		 // instance from the previous one.

		 // Object.keys will not include properties in the prototype so that only settings which are set as instance data are copied.
		 Object.keys(setting).forEach(function(val) {
			if ( val === "use_level" )
			  val = "_use_level"
			this[val] = setting[val]
		 }, this)
	  }

	   // void is used the same as the parenthisis enclosure method to make functions callable in the declaration. It returns the function declaration 
		// to void which returns it to the command line. Without void something else in the expression evaluation of the function is returned to the 
		// command line (which returns undefined).
	void function parse_args(args) {
		// This is called recursively on a arguments Object so that an arguments Objects inside of the arguments Object are also parsed. This is how
		// arguments as arguments are also accepted by the callee.

		 for ( var x = 0; x < args.length; x++ ) {
			if ( args[x] instanceof Print ) {
			  copy_setting.call(this, Object.keys(args[x].list()))
			} else if ( Object.prototype.toString.call(args[x]) === "[object Arguments]" ) {
			  parse_args.call(this, args[x])
			} else {
			  // This tells the set_option that it is already a fresh root copy of Print and to not make another one (it is used internally).
			  this._from_constructor = true
			  this.set_option(args[x])
			}
		 }
	  }.call(this, arguments)

	  this._old_platform = this.platform
	  this._last_command = null
	  this._output = ""
	  this._styleless_output = ""
	  this._cache = []
	  this._is_from_object = false
	  this.apply_arguments = []
	  this.formated = ""
	  this.plain = ""
	  //this.platform_index = [] 
	  this.plain_index = []
	  this.formated_index = []
	  // This may be included when another Print instance is passed into this constructor for a settings copy.
	}

	// These options are created one level deep (__proto__), in the Print() prototype chain. All of these options are user configurable
	// within the library but these properties (at this level), are only used as defaults sense there is no way to change them with the library api
	// (Print().__proto__ is the only way). If the prototype is set (e.g. Print.prototype.level = 3), ir the instance data, it will be used
	// instead of these values. A call to delete a property will also revert it back to the default value, e.g. Print.prototype.level and.or
	// Print().level will revert the level option back to the default value (from below).
	obj.parent = Print
	Print.prototype = obj
	//Print.prototype.parent = Print
	obj.style_map = style_map

	obj._remove_call = function() {
	  // This member removes all of the text added to the internal buffer created by calls the style map. The text is indexed by every call that is made
	  // to the style mapping memebre and thusly can be removed from the buffer. This mechanism works like the Array.splice memeber and also returns the
	  // removed call text. The console.log mechanism in gecko based browsers use printf like format with style styles so a separate Array is created
	  // to store them and passed to console.log via an apply.
		
		var uses_apply = this.style_map[this.platform].format.length >= 3
		if ( uses_apply )
			this.apply_arguments.splice.apply(this.apply_arguments, arguments)

	  var formated_index = this.formated_index.splice.apply(this.formated_index, arguments)[0] || 0
	  var plain_index = this.plain_index.splice.apply(this.plain_index, arguments)[0] || 0
	  // This is the text data which is removed
	  var removed = {formated: this.formated.substr(formated_index), plain: this.plain.substr(plain_index) }

	  // This is the internal buffer text which is now truncated.
	  this.formated = this.formated.substr(0, formated_index)
	  this.plain = this.plain.substr(0, plain_index)

	  return removed
	}

	obj.append_string = function(style_name, str) {
		if ( this.plain.length === this.character_limit )
			return this

		var plain = str && str.toString() || ""
		// TODO: Adding line breaks may be a nifty feature here.
		var truncated_msg = ".. Object truncated"
		truncated_msg = this.character_limit > (truncated_msg.length*3) && truncated_msg || ""
		if ( this.plain.length + plain.length > this.character_limit - truncated_msg.length )
			plain = plain.substr(0, this.character_limit - this.plain.length - truncated_msg.length ) + truncated_msg

		this.plain_index.push(this.plain.length)
		this.plain += plain

		if ( this.use_style ) {
			var theme = "", uses_apply = this.style_map[this.platform].format.length >= 3, platform = this.style_map[this.platform].use_theme || this.platform
			this.formated_index.push(this.formated.length)
			// The regex test will prevent styleization of values which do not contain a visable character.
			if ( this.style_map[platform][this.theme+"_level_"+this.level] ) {
				theme = this.theme+"_level_"+this.level
			} else {
				theme = Object.keys(this.style_map[platform].theme)[0]
			}
			if ( !theme )
				return this
			this.formated += this.style_map[this.platform].format(this.style_map[platform].theme[theme][style_name], plain, uses_apply && this.apply_arguments || null)
		}

		return this
	}

	return Print

})


;
}(this, 'object' == typeof module && module || void 0, 'function' == typeof define && define || void 0, 'function' == typeof requirejs && requirejs || void 0, {});
