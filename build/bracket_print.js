/* Generated by Brace_UMD 0.6.0 */
!function(e, i, o, t) {
    var __filename, __dirname, define, requirejs, require, n = {
        e: "object" == typeof module,
        i: !1,
        filename: "",
        factory: function(i, o, t, s) {
            i && i.constructor === Array && n.e && (s = t, t = o, o = i, i = n.filename), "string" != typeof i ? console.log("The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.") : o.every(function(o) {
                return o in e || !!console.log("The dependency", o, "is not loaded into the factory. Skipping loading of the module", i);
            }) && (e[i] = t.apply(t.prototype, o.map(function(e, i) {
                return this[e];
            }, e)));
        },
        requirejs: o,
        define: i,
        o: "object" == typeof t && t || {},
        t: function() {
            var e = {
                define: !this.o.auto_anonymous && this.define || this.n.bind(this),
                requirejs: this.requirejs || this.s.bind(this),
                require: this.requirejs || this.e && module.require || this.factory,
                factory: this.factory
            }, i = this.o.force_type && this.o.force_type.toString() || "";
            i && (!i in e ? console.log("The forced type", i, "specified as an option is not supported by Brace UMD. Supported types are", Object.keys(e)) : (console.log("Forcing use of the definition type", i), 
            e.requirejs = e.require = e.define = e.factory = e[i])), define = e.define, requirejs = e.requirejs, 
            require = e.require;
        },
        r: [ "config", "nextTick", "version", "jsExtRegExp", "isBrowser", "s", "toUrl", "undef", "defined", "specified", "onError", "createNode", "load", "exec" ],
        d: [ "amd", "require" ],
        n: function() {
            if (n.e && !this.define) try {
                this.define = module.require("amdefine")(module);
                for (var e in this.define) this.n[e] = this.define[e];
            } catch (e) {
                console.log("Unable to find amdefine module.", e.message);
            }
            var i = this.define || this.factory.bind(this);
            i == this.define ? console.log("Using proxied amdefine definition.") : console.log("Using factory proxied from amdefine call."), 
            i == this.define && this.o.auto_anonymous ? !0 !== this.i && arguments.length > 2 ? this.i = arguments[0] : arguments.length <= 2 && (this.i = !0) : (this.n = i, 
            this.t()), i.apply(i.prototype, arguments);
        },
        s: function() {
            if (commonjs_available && !this.requirejs) try {
                this.requirejs = this.a.require("requirejs");
                for (var e in this.requirejs) this.s[e] = this.requirejs[e];
            } catch (e) {
                console.log("Unable to find requirejs module.", e.message);
            }
            console.log("Using proxied requirejs method.");
            var i = this.requirejs || this.factory;
            this.s = i, i.apply(i.prototype, arguments);
        }
    };
    for (var s in n.d) n.n.__defineGetter__(n.d[s], function(e) {
        if (commonjs_available && !n.define) try {
            n.define = module.require("amdefine")(module);
            for (var i in n.define) delete this[i], this[i] = n.define[i];
            return console.log("Using proxied amdefine method."), n.define[e];
        } catch (e) {
            return console.log("Unable to find amdefine module.", e.message);
        }
    }.bind(null, n.d[s]));
    for (var s in n.r) n.s.__defineGetter__(n.r[s], function(e) {
        if (commonjs_available && !n.requirejs) try {
            n.requirejs = module.require("requirejs");
            for (var i in n.requirejs) delete this[i], this[i] = n.requirejs[i];
            return console.log("Using proxied requirejs method."), n.requirejs[i];
        } catch (e) {
            return console.log("Unable to find requirejs module.", e.message);
        }
    }.bind(null, n.r[s]));
    __filename = n.e && module.filename || "", __dirname = n.e && module.require("path").dirname(__filename) || "", 
    n.t(), n.e && (n.filename = module.require("path").basename(__filename));



define('serializer',['require'],function(require) {

	return function(msg, indent_string, previous_indent, level) {
	  // The Object to text parsing engine. This function will print any Object passed to it (including function text), in the most literal way possible.
	  // It can be recursively called within itself and also accepts modifiers to alter output. The indent_string argument contains how the
	  // subsequent Object levels will separate from the left margin. The indent_string is multiplied by the Object level when looping through
	  // adding the indent_string to the previous_indent (which is expanding), every time an Object is parsed while already parsing an Object
	  // (calling _serializer inside _serializer). This member can not be called outside this script with out breaking the overlying
	  // functionality of this script. The previous_indent argument/parameter will be placed at the start of each new object in the output (used internally).

	  // Store text adds platform dependent color syntax the strings passed in a parameters. The stings are stored internally in the store text
	  // instance until formatted or plain properties are accessed (it uses a getter).

	  // A simple way to stop Object parsing when the output becomes too large. The actual size of the internal string is maintained by the color addon.
	  if ( this.plain.length >= this.character_limit )
		 return

	  indent_string = typeof indent_string === "string" && indent_string || (this.style_map[this.platform].denote_space + this.style_map[this.platform].denote_space)
	  level = parseInt(level) || 0
	  previous_indent = previous_indent && previous_indent.toString() || ""

	  var compress_separator, line_separator = ""
	  if ( this.compress_level > 3 ) {
		 // There will be no indents, spaces or lines at the highest compression level.

		 indent_string = ""
		 compress_separator = ""
		 line_separator = ""
	  }
	  else if ( this.compress_level === 3 ) {
		 // No indents and lines are spaces as well.
		 indent_string = ""
		 compress_separator = this.style_map[this.platform].denote_space.toString()
		 line_separator = this.style_map[this.platform].denote_space.toString()
	  }
	  else if ( this.compress_level === 2 ) {

		 compress_separator = this.style_map[this.platform].denote_space.toString()
		 line_separator = this.style_map[this.platform].denote_line.toString()
	  }
	  else {
		 // The lowest compression settings are the same as the second most above (two), except some of the logic in the Object serializer below.

		 compress_separator = this.style_map[this.platform].denote_space.toString()
		 line_separator = this.style_map[this.platform].denote_line.toString()
	  }
	  if ( msg instanceof (this.parent || function(){}) ) {

		this._serializer(msg.toString())
	  }
	  else if ( msg === null ) {

		this.append_string("null", "null")
	  }
	  else if ( typeof msg === "boolean" ) {

		this.append_string("boolean", msg.toString())
	  }
	  else if ( msg !== msg ) { // NaN is the only js object which is not equal to itself

		this.append_string("not_a_number", "NaN")
	  }
	  else if ( msg instanceof Error ) {

		var stack_string = msg.stack.split("\n")
		this.append_string("namespace", stack_string.splice(0,1) + line_separator)
		this.append_string("function_body", stack_string.join(line_separator))
	  }
	  else if ( typeof msg === "undefined" ) {

		this.append_string("undefined", "undefined")
	  }
	  else if ( typeof Buffer !== "undefined" && msg.__proto__ && msg.__proto__.constructor === Buffer ) {

		this._serializer(msg.toString())
	  }
	  else if ( typeof msg === "object" || typeof msg === "function" ) {
		 // Here is the man object parsing function. It will print all of the data from a Object including functions and prototypes.
		 var key_grab = !this.enumerate_all && Object.keys || Object.getOwnPropertyNames
		 this._is_from_object = true
		 var keys = key_grab(msg), is_primitive_object = false
		 this._cache[level] = this._cache[level] || []
		 // There is no need to put primitive Objects into the cache sense they are never circular dependencies to another one.
		 if ( typeof msg === "object" && typeof msg.valueOf === "function" && msg.valueOf() !== msg ) {
			is_primitive_object = true
		 } else {
			this._cache[level].push(msg)
		 }

		 for ( var n = 0; n < level; n++ ) {
			for ( var x = 0; x < this._cache[n].length; x++ ) {
			  if ( typeof msg === "object" && msg === this._cache[n][x] ) {
				 // Circular reference found, discard object processing

				 var circ_text = "[[Circular duplicate of "
				 var obj_qualifier = key_grab(this._cache[n][x])
				 obj_qualifier.unshift("")
				 obj_qualifier = obj_qualifier.join(" "+(this._cache[n-1]&&this._cache[n-1][x]||"<-"))
				 if ( circ_text.length+obj_qualifier.length > 75 )
				 obj_qualifier = obj_qualifier.substr(0, 71-circ_text.length) + ".."

				 this.append_string("namespace", circ_text)
				 this.append_string("scope_container", "{"+compress_separator)
				 this.append_string("function_body", obj_qualifier)
				 this.append_string("scope_container", compress_separator+"}")
				 this.append_string("namespace", "]]")
				 return
			  }
			}
		 }
		 var is_array = msg.constructor === Array
		 if ( typeof msg === "function" ) {

			// This regex will strip out the function: declaration, name, parameters and body. The body is only parsed for indentation and will use the string
			// provided as indent string.
			var f_str = msg.toString().match(/function(?:\ |\n)*(\S*)\(([^\)]*)\)(?:\ |\n)*\{((?:.|\n)*)\}(?:\ |\n)*/i) || []
			var f_name = f_str[1] || ""
			var f_parameter = f_str[2] || ""
			var f_body = f_str[3] || ""

			this.append_string("namespace", "function ")
			this.append_string("string", f_name)
			var param = f_parameter.split(",")
			// The parameter list is striped from the function text which will produce an Array containing an empty string if no parameters are used in the
			// Function. E.g. function(cool) -> ["cool"], function() -> [""]. The parenthesis will only have space (compress_separator), if parameters are
			// used in the function. Note: the compress_separator adjusts pending the this.compress_level.
			this.append_string("scope_container", "(" + (param[0] && compress_separator || ""))

			// Make the parameter string fro the list
			param.forEach(function(val) {
			  this.append_string("variable", val)
			  this.append_string("comma", ",")
			}, this)

			// Remove the last comma from the parameter string
			this.remove_call(-1)
			this.append_string("scope_container", (param[0] && compress_separator || "") + ")" + compress_separator)
			this.append_string("scope_container", "{" + compress_separator)

			if ( !this.truncate_function ) {

			  // Replace the first line with a new line if contains text before a newline so that it is always printing with a newline after
			  // the function declaration.
			  var body_indent = previous_indent + indent_string 
			  // This needs to be what the actual newline is for the platform because function text must maintain newlines to function properly.
			  // Replace every newline in the function string with current indentation string the text and then the desired newline.
			  var has_end_new_line = true
			  if ( ! /\n/.test(f_body) )
				 f_body = "\n" + f_body + "\n"
			  f_body.replace(/(.*)(\n+)/g, (function() {
				 // If line was only white space or newlines than it can be removed from processing if the compress level is high enough.

				 var has_ascii = arguments[1].replace(/\s*/g, "")
				 if ( this.compress_level >= 4 && !has_ascii )
					return ""
				 // More than two newlines will be replace with two newlines when compression levels are two or three
				 if ( ( this.compress_level === 2 || this.compress_level === 3) && /\n{2,}/.test(arguments[2]) )
					arguments[2] = "\n\n"

				 // The indent string should not be used if the line contains no ascii characters (this avoids indent strings where there
				 // only is white space in a black line.
				 if ( has_ascii  )
					this.append_string("indent", body_indent)

				 has_end_new_line = false
				 var indent = this.style_map[this.platform].denote_line.toString()
				 if ( this.compress_level < 4 ) {
					var newline = arguments[2].match(/\n/g)
					newline.pop()
					newline.forEach(function() {
					  has_end_new_line = true
					  indent += this.style_map[this.platform].denote_line.toString()
					})
				 }
				 this.append_string("function_body", arguments[1]||"")
				 this.append_string("indent", indent)
			  }).bind(this)) // End of f_body.replace function
			  if ( !has_end_new_line )
				 this.remove_call(-1)
			} // End of if  truncate_function
			else {
			  this.append_string("function_body", compress_separator + "..." + compress_separator)
			}
		 }
		 else {
			this.append_string("scope_container", is_array&&"["||"{" + (this.compress_level < 3 && this.style_map[this.platform].denote_space.toString() || ""))
		 }

		 var cnt = 1
		 if ( !keys.length ) {

			if ( msg.__proto__ && typeof msg.__proto__ === "object" && key_grab(msg.__proto__).length ) {

				 this.append_string("indent", line_separator + previous_indent + indent_string)
				 this.append_string("namespace", "__proto__")
				 this.append_string("colon", ":" + compress_separator)
				 this._serializer(msg.__proto__, indent_string, previous_indent + indent_string, level+1)

			  if ( is_primitive_object ) {

				 this.append_string("indent", line_separator + previous_indent + indent_string)
				 this.append_string("namespace", "[[PrimitiveValue]]")
				 this.append_string("colon", ":" + compress_separator)
				 this._serializer(msg.valueOf(), indent_string, previous_indent + indent_string, level+1)
				 this.append_string("comma", "," + compress_separator)
				 // This happens when the Object is a primitive value with Object keys set (new String("abc"). The length property will not be added
				 // sense it is a property of the primitive value (not the Object). Therefore the length property is added as a design choice.
				 if ( typeof msg.length !== "undefined" ) {
					this.append_string("indent", line_separator + previous_indent + indent_string)
					this.append_string("string", "length")
					this.append_string("colon", ":" + compress_separator)
					this._serializer(msg.length, indent_string, previous_indent + indent_string, level+1)
					this.append_string("comma", "," + compress_separator)
				 }
				 this.remove_call(-1)
			  }
			}
			this.append_string("indent", line_separator + previous_indent)
			this.append_string("scope_container", is_array&&"]"||"}")
			this.append_string("comma", "," + compress_separator)
		 }

		 // Object.keys are used here to loop instead of the in operator so that the __proto__ keys are not looped over sense they were handled above.
		 for ( var x = 0; x < keys.length; x++ ) {
			var o = keys[x]

			if ( this.plain.length >= this.character_limit )
			  return

			// Add the indent string to the beginning of the parsing loop or if the item is an Object. This is the primary formatting controller.
			var is_property_based = !!(typeof msg[o] === "object" && msg[o] !== null && msg[o] !== undefined && key_grab(msg[o]).length )

			if ( cnt !== 1 && this.compress_level < 2 )
			  this.append_string("indent", line_separator + previous_indent + indent_string)
			if ( cnt === 1 || is_property_based ) {
			  this.append_string("indent", line_separator + previous_indent + indent_string)
			  if ( cnt === 1 && typeof msg.valueOf === "function" && msg.valueOf() !== msg ) {
				 this.append_string("namespace", "[[PrimitiveValue]]")
				 this.append_string("colon", ":" + compress_separator)
				 this._serializer(msg.valueOf(), indent_string, previous_indent + indent_string, level+1)
				 this.append_string("comma", "," + line_separator)
				 this.append_string("indent", compress_separator)
			  }
			  // If the item has a primitive value than it will not be equal to it self and therefor the primitive value should be displayed.
			}
			if ( !is_array ) {
			  // _serializer is used here to format the qualifiers strings if this loop is parsing an object. This should only add numbers and strings as this
			  // is the only type of qualifiers ecma allows (for now:).
			  this._serializer(o)
			  this.append_string("colon", ":" + compress_separator) // Object separator makes it more human readable by adding space. This changes with the compress_level.
			}
			// recursively call this function to parse the object. The indent_string is added to the beginning to nest the output. It is important to
			// use level+1 here instead of assignment operators like level++ or ++level so that it is only passed in with an increment ans this
			// function call keeps the value of level. This way each call to _serializer uses a level incremented by one from the calling _serializer.

			// Here parses nested Objects from within Objects and stops at the level specified in the depth_limit setting. This is good for super massive
			// Objects like browser self, window, jquery and document or for other practical use. Object serialization will stop when the specified depth
			// is reached in an Object which contains more Object to serializer. The Object serialization will be replaced with a String describing the Object.
			// Any non-literal Objects will be printed on the last depth parsing level (which is what the !is_property_based test is for).
			if ( level < this.depth_limit-1 || !is_property_based ) {
			  this._serializer(msg[o], indent_string, previous_indent + indent_string, level+1)
			} else {
			  var len = key_grab(msg[o]).length
			  this.append_string("namespace", new this.parent().add("[[", is_array && "Array" || "Object", " with ", len, " propert")
			  .add(len === 1 && "y" || "ies", "]]")
			  )
			}

			this.append_string("comma", "," + compress_separator)
			// These two positions of the loop separate the ___proto__ and property values of the Object which is being parsed.
			if ( cnt === keys.length ) {

			  // This happens when the Object is a primitive value with Object keys set (new String("abc"). The length property will not be added
			  // sense it is a property of the primitive value (not the Object). Therefore the length property is added as a design choice.
			  if ( is_primitive_object && typeof msg.length !== "undefined" ) {

				 this.append_string("indent", line_separator + previous_indent + indent_string)
				 this.append_string("string", "length")
				 this.append_string("colon", ":" + compress_separator)
				 this._serializer(msg.length, indent_string, previous_indent + indent_string, level+1)
				 this.append_string("comma", "," + compress_separator)
			  }
			  // Remove the last comma from the item list and add the newline and indentation.
			  this.remove_call(-1)

			  if ( msg.__proto__ && typeof msg.__proto__ === "object" && Object.keys(msg.__proto__).length ) {

				 this.append_string("comma", "," + compress_separator)
				 this.append_string("indent", line_separator + previous_indent + indent_string)
				 this.append_string("namespace", "__proto__")
				 this.append_string("colon", ":" + compress_separator)
				 this._serializer(msg.__proto__, indent_string, previous_indent + indent_string, level+1)
			  }
			  this.append_string("indent", line_separator + previous_indent)
			  this.append_string("scope_container", is_array&&"]"||"}")
			  this.append_string("comma", "," + compress_separator)
			}
			cnt++
		 }

		 // Remove the last comma from the parsing output. It is the last thing to be stored so a simple call to remove the last call will suffice.
		 this.remove_call(-1)
		 // An Object which is being parsed will always have a level. It is set as soon as Object parsing begins.
		 this._is_from_object = !!level
	  }
	  else if ( typeof msg === "number" ) {

		this.append_string("number", msg.toString())
	  }
	  else if ( typeof msg === "string" ) {
		// The quotes are only added if this _serializer call was called from another _serializer call. Otherwise all calls with strings would have quotes.

		 if ( this._is_from_object ) {
			this.append_string("quote", this.denote_quoting)
			this.append_string("string", msg)
			this.append_string("quote", this.denote_quoting)
		 } else {
			this.append_string("string", msg)
		 }
	  }
	  else {
		 // Nothing should be able to get here as all of the types of str should be caught above.
		 this.append_string("namespace", msg.toString())
	  }
	  return this.style_map[this.platform]
	}

})

;
/*
Copyright (c) 2017 Robert Edward Steckroth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

  Brace Prototype is a nodejs and browser script which returns a method that is used within prototypes to control properties with the chain.

 Author: Robert Edward Steckroth II, Bustout, <RobertSteckroth@gmail.com>
*/

/* Generated by Brace_UMD 0.6.0 */
!function(e, i, t, r) {
    var o, n, s, a, f = {
        e: "object" == typeof module,
        i: !1,
        filename: "",
        factory: function(i, t, r, o) {
            i && i.constructor === Array && f.e && (r, r = t, t = i, i = f.filename), "string" != typeof i ? console.log("The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.") : t.every(function(t) {
                return t in e || !!console.log("The dependency", t, "is not loaded into the factory. Skipping loading of the module", i);
            }) && (e[i] = r.apply(r.prototype, t.map(function(e, i) {
                return this[e];
            }, e)));
        },
        requirejs: t,
        define: i,
        o: "object" == typeof r && r || {},
        t: function() {
            var e = {
                define: !this.o.auto_anonymous && this.define || this.n.bind(this),
                requirejs: this.requirejs || this.s.bind(this),
                require: this.requirejs || this.e && module.require || this.factory,
                factory: this.factory
            }, i = this.o.force_type && this.o.force_type.toString() || "";
            i && (!i in e ? console.log("The forced type", i, "specified as an option is not supported by Brace UMD. Supported types are", Object.keys(e)) : (console.log("Forcing use of the definition type", i), 
            e.requirejs = e.require = e.define = e.factory = e[i])), n = e.define, s = e.requirejs, 
            a = e.require;
        },
        r: [ "config", "nextTick", "version", "jsExtRegExp", "isBrowser", "s", "toUrl", "undef", "defined", "specified", "onError", "createNode", "load", "exec" ],
        d: [ "amd", "require" ],
        n: function() {
            if (f.e && !this.define) try {
                this.define = module.require("amdefine")(module);
                for (var e in this.define) this.n[e] = this.define[e];
            } catch (e) {
                console.log("Unable to find amdefine module.", e.message);
            }
            var i = this.define || this.factory.bind(this);
            i == this.define ? console.log("Using proxied amdefine definition.") : console.log("Using factory proxied from amdefine call."), 
            i == this.define && this.o.auto_anonymous ? !0 !== this.i && arguments.length > 2 ? this.i = arguments[0] : arguments.length <= 2 && (this.i = !0) : (this.n = i, 
            this.t()), i.apply(i.prototype, arguments);
        },
        s: function() {
            if (commonjs_available && !this.requirejs) try {
                this.requirejs = this.a.require("requirejs");
                for (var e in this.requirejs) this.s[e] = this.requirejs[e];
            } catch (e) {
                console.log("Unable to find requirejs module.", e.message);
            }
            console.log("Using proxied requirejs method.");
            var i = this.requirejs || this.factory;
            this.s = i, i.apply(i.prototype, arguments);
        }
    };
    for (var u in f.d) f.n.__defineGetter__(f.d[u], function(e) {
        if (commonjs_available && !f.define) try {
            f.define = module.require("amdefine")(module);
            for (var i in f.define) delete this[i], this[i] = f.define[i];
            return console.log("Using proxied amdefine method."), f.define[e];
        } catch (e) {
            return console.log("Unable to find amdefine module.", e.message);
        }
    }.bind(null, f.d[u]));
    for (var u in f.r) f.s.__defineGetter__(f.r[u], function(e) {
        if (commonjs_available && !f.requirejs) try {
            f.requirejs = module.require("requirejs");
            for (var i in f.requirejs) delete this[i], this[i] = f.requirejs[i];
            return console.log("Using proxied requirejs method."), f.requirejs[i];
        } catch (e) {
            return console.log("Unable to find requirejs module.", e.message);
        }
    }.bind(null, f.r[u]));
    o = f.e && module.filename || "", f.e && module.require("path").dirname(o) || "", 
    f.t(), f.e && (f.filename = module.require("path").basename(o)), n("brace_prototype", [], function() {
        return function(e) {
            if ("object" != typeof e) return !!console.warn("Brace prototype must be passed an Object to assign additional members.") || e;
            var i = {};
            for (var t in e) i[t] = e[t];
            var r = function(e) {
                if (this.hasOwnProperty(e)) {
                    if ("function" == typeof Object.getPrototypeOf) return !!Object.getPrototypeOf(this)[e] && delete this[e] || !0;
                    for (var i = this.__proto__; i; i = i.__proto__) if (e in i) return delete this[e] || !0;
                }
                return !1;
            };
            return e.clear = function() {
                if (!arguments.length) for (var e in i) r.call(this, e);
                for (var t in arguments) arguments[t] in i ? r.call(this, arguments[t]) : console.log("The qualifier", arguments[t], "was passed to a brace prototype instance which does not have it listed.", "You should either: insert the qualifier to the constructor Object parameter or add the qualifier with the add_qualifier member.");
            }, e.extend = function(e) {
                return Object.getOwnPropertyNames(e).forEach(function(i) {
                    var t = Object.getOwnPropertyDescriptor(e, i);
                    Object.defineProperty(this, i, t);
                }, this), this;
            }, e.add_qualifier = function(t) {
                i[t] = i[t] || null, e[t] = e[t] || null;
            }, e.remove_qualifier = function(e) {
                delete i[e];
            }, e.list = function() {
                return i;
            }, e;
        };
    }), f.i.length && n([ f.i ], function(e) {
        return e;
    });
}(this, "function" == typeof define && define || void 0, "function" == typeof requirejs && requirejs || void 0, {
    auto_anonymous: !0
});
define('brace_prototype', ['brace_prototype/brace_prototype'], function (main) { return main; });

define("brace_prototype/brace_prototype", function(){});




define('proto_object',["./serializer", "brace_prototype"], function(serializer, proto) {

	var p = proto({
		// All user configurable options go in here so that brace_prototype can manage them.

		use_style: true,
		use_title_stamp: function() { return new Date() },
		log_title: "",
		theme: "light",
		// The compression level of the Object serializations. Higher numbers create more spacious formatting. Level one removes all white space and 
		// new lines from the Object.
		compress_level: 2,
		use_title: true,
		indentation_string: "   ",
		platform: !console.log(typeof module) && typeof module === "object" && typeof module.exports === "object" && "terminal" || "browser",
		//platform: typeof module === "object" && typeof module.exports === "object" && "terminal" || "browser",
		// This will prevent Object serialization to traverse to a deeper level with Objects (it avoids call stack max-out conditions).
		depth_limit: 800,
		// The logging storage and serializations will be cut short and truncated to this character_limit.
		character_limit: Math.pow(2,28),
		truncate_function: false,
		// Objects that are built-in to javascript have the enumerable flag set to false. In order to parse these Objects (and other Objects), the
		// enumerate_all flag needs to be set.
		enumerate_all: false,
		denote_quoting: "\"",
		// Note: use_level is contained one level up in the chain and should stay that way.
		// This is the level which needs to be in the range set to use_level. All serializations, logging and storage will be ignored (disabled), if
		// the level is not a match to the use_level.
		level: 1,
		// TODO: this should have an option to keep the same as the level.
		// This is used to set the level of any messages which are logged internally in the p library.
		internal_level: 2,
	})

	return p.extend({
		_serializer: serializer,
		get use_level() {

		  return this._use_level
		},
		set use_level(value) {
		  // This setter accepts strings, numbers and Arrays. Arrays should be in pairs denoting ranges. Two Array values of the same value need to be set
		  // to denote a single value. E.g. [1, 1, 4, 6] denotes a level of either 1 or on/between 4 and 6. Strings can be passed in lieu of Array pairs for
		  // more human friendly syntax. When strings are passed in: ranges are two numbers separated with a dash and single value levels are separated
		  // with commas. E.g. use_level = "1,4-6" denotes a level of either 1 or on/between 4 and 6 like the example above. White space is ignored and strings
		  // are parsed as numbers in any case (Array or String). The value of use_level will be set to [-Infinity, Infinity] (which will match all levels),
		  // if an empty string or the string "all" is set. Note: The only way to use negative numbers is to passed in Array pairs.

		  if ( value === "all" || value === "" )
			 return this._use_level = [-Infinity, Infinity]

		  if ( Object.prototype.toString.call(value) === "[object Array]" ) {
			 // Arrays can only be passed in as pairs of ranges (which is what non-Array values set to use_level are converted to.

			 if ( value.length % 2 )
				value.pop()
		  } 
		  else {
			 // All processing is utilized with Arrays in this function.
			 value = [value]
		  }

		  value = value.join("-")
		  this._use_level = parsed = []

		  // Split the commas and dashes into a uniform parse-able Array.
		  value.toString().replace(/\ +/g, "").replace(/\-\-([^\-]{1})/g, "-minus$1").replace(/^\-/, "minus").split(",").forEach(function(val) {

			 if ( !val )
				return

			 var range = val.split("-")
			 if ( range.length < 2 )
				range.push(range[0])

			 for ( var x = 0; x < range.length; x+=2 ) {

				var first_is_negative = /minus/.test(range[0]), second_is_negative = /minus/.test(range[1])
				if ( /Infinity/.test(range[x]) )
				  range[x] = Infinity
				else
				  range[x] = parseInt(range[x].replace(/minus/, ""))

				if ( /Infinity/.test(range[x]) )
				  range[x+1] = Infinity
				else
				  range[x+1] = parseInt(range[x+1].replace(/minus/, ""))

				if ( range[x] !== range[x] || range[x+1] !== range[x+1] )
				  return new this.parent({level: this.internal_level}).log("The value set to use_level can not be parsed as an integer:", range)

				// If the string contained a negative number (the range dash is already compensated for).
				if ( first_is_negative )
				  range[x] *= -1
				if ( second_is_negative )
				  range[x+1] *= -1

			 }
			 parsed = parsed.concat(range)
		  })
		  this._use_level = parsed
		},

		// Don't delete me! This is expected to always exist internally.
		_use_level: [-Infinity, Infinity], // The default use_level option will initially be altered by this getter until the parent level prototype chain
		toColorString: function() {
		  // These two members return strings so no chaining mechanism is utilized (like a getter returning a function which returns the instance). They
		  // do accept parameters to serialize just like all other printing commands. Note: this method is very fast (especially without arguments), as
		  // it only returns an Object property.

			var formated = ""
			if ( !arguments.length )
				formated = this.formated
			else 
				formated = this._print_command(this._last_command || "space").apply(this, arguments).formated 

		  return formated + this.style_map[this.platform].format.length >= 3 && this.apply_arguments.length && this.apply_arguments.join(" ") || ""
		},
		toString: function() {
		  // These two members return strings so no chaining mechanism is utilized (like a getter returning a function which returns the instance). They
		  // do accept parameters to serialize just like all other printing commands. Note: this method is very fast (especially without arguments), as
		  // it only returns an Object property.

		  return this._print_command(this._last_command || "space").apply(this, arguments).plain
		},
		set_option: function() {
		  // The other way of setting the options which returns this to maintain call chains. Objects, p() instances and Strings can be passed into
		  // the set_option method. Any Strings will be used to set the log_title options. Objects passed in after other Objects will override the previous
		  // Object data set so that the last Object in the parameter list is has the highest priority.

		  var print = ((this._is_chained || this._from_constructor) && this) || new this.parent(this)
		  // The is_chained property tells any printing commands to create a new instance or use the existing.
		  if ( !this._from_constructor )
			 print._is_chained = true
		  for ( var i = 0; i < arguments.length; i++ ) {

			 // Log titles can be passed in as strings (this is the only allowable non-Object parameter.
			 if ( typeof arguments[i] === "string" )
				arguments[i] = {log_title: arguments[i]}
			 if ( arguments[i] instanceof this.parent ) {
				arguments[i] = arguments[i].list()
			}

			 var mutable = print.list()

			 for ( var n in arguments[i] ) {
				if ( n in mutable || n === "use_level" ) {
				  if ( this._from_constructor )
					 p[n] = arguments[i][n]
				  else
					 p[n] = arguments[i][n]
				} else {
				  new this.parent({level: this.internal_level})
					 .sp("Option", n, "is not a brackit print option. Use .list() to see all user configurable options:").line(mutable).log()
				}
			 }
		  }
		  this._from_constructor = false
		  return print
		},
		new_copy: function() {
			// This is how bracket print transfers options to other instances. It is best to make a single print instance and then and pass the copy 
			// into another Print copy. It is in this way that all of the p objects contain inherit settings and then can have the options changed 
			// individually if necessary. The function parameters work the same way as the set_option member and Print constructor.
			return new this.parent(this, arguments)
		},
		get clear() {
			// Remove all of the text storage from the current p instance.

			return (function() {
			  // Splices all text storage from the beginning of the bufferize instance.
			  this.remove_call(0)
			  return this
			}).bind(this)
		},
		//----------------------------------------------------------------------------
		get sp() {

		 return this._print_command("space")
		},
		get space() {

		 return this._print_command("space")
		},
		get tab() {

		 return this._print_command("tab")
		},
		get line() {

		 return this._print_command("line")
		},
		get add() {

		 return this._print_command("add")
		},
		// ---------------------------------------------------------------------------
		// Here are all of the print commands which ease string formation.
		_print_command: function(call_name) {

		 // This is used internally whenever a input member is called. The _chain is preliminary for the _serialize member which converts Objects to text.
		 // this is passed into the p constructor so that the current settings will be saved.
		 var print = this._is_chained && this || new this.parent(this)
		 print._is_chained = true
		 print._last_command = call_name

		 return (function() {

			// No need to process if no arguments were passed in. As long as the _print_command returns a function which returns the instance.
			if ( !arguments.length )
			 return this
			for ( var x = 0; x < this.use_level.length; x += 2 )
			  if ( parseInt(this.level) >= this.use_level[x] && parseInt(this.level) <= this.use_level[x+1] ) {
				 return this._chain.apply(this, arguments)
			 }
			 return this

		 }).bind(print)
		},
		get _chain() {
		 // This is the main printing member.
		 return function() {

			var indentation = this.indentation_string.replace(/\t/g, this.style_map[this.platform].denote_tab).replace(/\n/g, this.style_map[this.platform].denote_line).replace(/\ /g, this.style_map[this.platform].denote_space)

			this._cache = []
			for ( var i = 0; i < arguments.length; i++ ) {

			  if ( this.plain.length && typeof this.style_map[this.platform]["denote_"+this._last_command] !== "undefined" ) {
				 // Add the last separator relating to the previous printing command called
				 this.plain += this.style_map[this.platform]["denote_"+this._last_command]
				 this.formated += this.style_map[this.platform]["denote_"+this._last_command]
			  }

			  this._serializer(arguments[i], indentation)
			  // Empty the Object processing cache which is used to ensure circular object references do not occur within serialization.
			  this._cache = []
			}
			return this
		 }
		},
		get log() {

		 // this is passed into the parent (Print constructor) so that the current settings will be used.
		 var print = this._is_chained && this || new this.parent(this)
		 print._is_chained = true
		 return (function() {
			var in_range = false
			for ( var x = 0; x < this.use_level.length; x += 2 )
			  if ( parseInt(this.level) >= this.use_level[x] && parseInt(this.level) <= this.use_level[x+1] ) {
				  in_range = true
				  break
			 }

		 if ( !in_range )
			 return this

			if ( arguments.length > 0 ) {
			  // Call the last command used before this log again.
			  if ( this[this._last_command] ) {
				this[this._last_command].apply(this, arguments)
			  }
			  else {
				 this.space.apply(this, arguments)
			  }
			}

			if ( this.formated ) {

			  // Append the logging title if there is one set and then turn the entire output string
			  // into an array to pass with the console.log.apply
			  var style = this.style_map[this.platform], theme = this.theme + "_level_" + this.level, title = ""
			  if ( this.use_title && (this.log_title || this.use_title_stamp) )
				  title = "[" + (typeof this.use_title_stamp === "function" && this.use_title_stamp() || "") + 
			  	  (this.use_title_stamp && this.log_title&&" - "||"") + this.log_title + "] "

			  this.append_string("title", title)

			  var c_args = [(this.formated||this.plain)+this.formated]
			  if ( this.style_map[this.platform].format.length >= 3 )
				 c_args = c_args.concat(this.apply_arguments)

			  console.log.apply(console, c_args)
			}
			return this
		 }).bind(print)
		},
		get log_false() {

		 return (function() {
			this.log.apply(this, arguments)
			return false
		 }).bind(this)
		},
		get log_true() {

		 return (function() {
			this.log.apply(this, arguments)
			return true
		 }).bind(this)
		},
		get log_undefined() {

		 return (function() {
			this.log.apply(this, arguments)
			return 
		 }).bind(this)
		},
		get log_null() {

		 return (function() {
			this.log.apply(this, arguments)
			return null
		 }).bind(this)
		},
		get log_empty() {

		 return (function() {
			this.log.apply(this, arguments)
			return ""
		 }).bind(this)
		},

	})

})	
;



define('style_map',["require"], function(require) {

	return {

		browser: {

			denote_line: "\n",
			denote_tab: "\t;",
			denote_space: " ",
			denote_add: "",
			use_theme: "html",
			format: function(style_value, str, apply_args) {
				apply_args.push(style_value)
				return "%c"+str
			},
		},
		html: {

			denote_line: "<br>",
			denote_tab: "&#09;",
			denote_space: "&nbsp;",
			denote_add: "",
			format: function(color_value, str) {
				return "<span style='"+color_value+";'>"+str+"</span>"
			},
			theme: {

				light_level_1: {
					quote: "color: #454343;",
					number: "color: green",
					string: "color: #b91db3",
					function_body: "color: #656565",
					not_a_number: "color: #249e93",
					null: "color: #249e93",
					boolean: "color: red",
					comma: "color: #323232",
					undefined: "color: #f4d400",
					scope_container: "color: #286f4f",
					colon: "color: #363533",
					namespace: "color: #690900", // I.g. .__proto__, [[PrimitiveValue}}
					indent: "color: #c2bab8",
					title: "color: #0a0a0a",
					variable: "color: #4a6a27",

				},
				light_level_2: {
					quote: "color: #454343; font-weight: bold;",
					number: "color: green; font-weight: bold",
					string: "color: #b91db3; font-weight: bold",
					function_body: "color: #656565; font-weight: bold",
					not_a_number: "color: #249e93; font-weight: bold",
					null: "color: #249e93; font-weight: bold",
					boolean: "color: red; font-weight: bold",
					comma: "color: #323232; font-weight: bold",
					undefined: "color: #f4d400; font-weight: bold",
					scope_container: "color: #286f4f; font-weight: bold",
					colon: "color: #363533; font-weight: bold",
					namespace: "color: #690900; font-weight: bold", // I.g. .__proto__, [[PrimitiveValue}}
					indent: "color: #c2bab8; font-weight: bold",
					title: "color: #0a0a0a; font-weight: bold",
					variable: "color: #4a6a27; font-weight: bold",

				},
				dark_level_1: {
					quote: "color: #d2d2d2",
					number: "color: green",
					string: "color: #e9e9e9",
					function_body: "color: #a7a7a7",
					not_a_number: "color: yellow",
					null: "color: #5bc3ba; font-weight: bold",
					boolean: "color: red",
					comma: "color: #787878",
					undefined: "color: #e9d234",
					scope_container: "color: #80ab96",
					colon: "color: #dfd9b3",
					namespace: "color: #e05c50", // E.g. .__proto__ [[PrimitiveValue}}
					indent: "color: #373332",
					title: "color: #f2f2f2; font-weight: bold",
					variable: "color: #baeb83",

				},
				dark_level_2: {
					quote: "color: #d2d2d2; font-weight: bold",
					number: "color: green; font-weight: bold",
					string: "color: #e9e9e9; font-weight: bold",
					function_body: "color: #a7a7a7; font-weight: bold",
					not_a_number: "color: yellow; font-weight: bold",
					null: "color: #5bc3ba; font-weight: bold; font-weight: bold",
					boolean: "color: red; font-weight: bold",
					comma: "color: #787878; font-weight: bold",
					undefined: "color: #e9d234; font-weight: bold",
					scope_container: "color: #80ab96; font-weight: bold",
					colon: "color: #dfd9b3; font-weight: bold",
					namespace: "color: #e05c50; font-weight: bold", // E.g. .__proto__ [[PrimitiveValue}}
					indent: "color: #373332; font-weight: bold",
					title: "color: #f2f2f2; font-weight: bold",
					variable: "color: #baeb83; font-weight: bold",

				},
			},
		 },
		 terminal: {

			denote_line: "\n",
			denote_tab: "\t;",
			denote_space: " ",
			denote_add: "",
			format: function(style_value, val) {
				return style_value+val
			},
			theme: {
				light_internal: {
					all: "\033[0;31m",
				},
				light_level_1: {
					quote: "\033[0;30m",
					number: "\033[0;32m",
					string: "\033[0;35m",
					function_body: "\033[0;30m",
					not_a_number: "\033[0;33m",
					null: "\033[0;36m",
					boolean: "\033[0;31m",
					comma: "\033[0;30m",
					undefined: "\033[0;32m",
					scope_container: "\033[0;36m",
					colon: "\033[0;30m",
					namespace: "\033[0;31m", // I.g. .__proto__, [[primitivevalue}
					indent: "\033[0;37m",
					title: "\033[0;35m",
					variable: "\033[0;34m",

				},
				light_level_2: {
					quote: "\033[1;30m",
					number: "\033[1;32m",
					string: "\033[1;35m",
					function_body: "\033[1;30m",
					not_a_number: "\033[1;33m",
					null: "\033[1;36m",
					boolean: "\033[1;31m",
					comma: "\033[1;30m",
					undefined: "\033[1;32m",
					scope_container: "\033[1;36m",
					colon: "\033[1;30m",
					namespace: "\033[0;31m", // I.g. .__proto__, [[primitivevalue}
					indent: "\033[1;37m",
					title: "\033[1;32m",
					variable: "\033[1;34m",

				},
				dark_level_1: {
					quote: "\033[0;37m",
					number: "\033[0;32m",
					string: "\033[0;35m",
					function_body: "\033[0;30m",
					not_a_number: "\033[0;33m",
					null: "\033[0;36m",
					boolean: "\033[0;31m",
					comma: "\033[0;37m",
					undefined: "\033[0;32m",
					scope_container: "\033[0;36m",
					colon: "\033[0;37m",
					namespace: "\033[0;31m", // I.g. .__proto__, [[primitivevalue}}
					indent: "\033[0;30m", // If an indentation_string is provided it will be colorized as this.
					title: "\033[0;37m",
					variable: "\033[0;34m", // E.g. function( num, opt ) { .
													//                ^^^  ^^^
				},
				dark_level_2: {
					quote: "\033[1;37m",
					number: "\033[1;32m",
					string: "\033[1;35m",
					function_body: "\033[1;30m",
					not_a_number: "\033[1;33m",
					null: "\033[1;36m",
					boolean: "\033[1;31m",
					comma: "\033[0;37m",
					undefined: "\033[1;32m",
					scope_container: "\033[1;36m",
					colon: "\033[1;37m",
					namespace: "\033[1;31m", // I.g. .__proto__, [[primitivevalue}}
					indent: "\033[1;30m", // If an indentation_string is provided it will be colorized as this.
					title: "\033[1;37m",
					variable: "\033[1;34m", // E.g. function( num, opt ) { .
													//                ^^^  ^^^
				},
			},
		}

	}

})
;
/*
  Brackit print is a printing and logging tool for javascript engines which supplies literal ECMA Object serialization.

  Copyright (C) 2017  Robert Edward Steckroth II <RobertSteckroth@gmail.com>

 this file is a part of Brackit print

 Brackit Print is free software: you can redistribute it and/or modify it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Brackit print is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

// Author: Robert Edward Steckroth, Bustout, <RobertSteckroth@gmail.com>

// This will be striped out by the requirejs optimizer. It is mainly used so that this library source can be evaluated in primitive development.


define('bracket_print',["require", "./proto_object", "./style_map"], function(require, obj, style_map) {
	
	var Print = function() {
	  // This accepts all of the parameters as set_option does. 

		// This will call the constructor with the same arguments as initially passed as a new instance if it was not done so to ensure a new instance is
		// always created when invoking the constructor.
	  if ( !(this instanceof Print) ) {
		 var call_instance = Print
		 for ( var x = 0; x < arguments.length; x++ )
			call_instance = call_instance.bind(call_instance.prototype, arguments[x])
		 return new call_instance()
	  }

	  var copy_setting = function(setting) {
		 // Copy the settings Object passed in to the prototype of the current instance. This effectively copies all of the necessary options to the current
		 // instance from the previous one.

		 // Object.keys will not include properties in the prototype so that only settings which are set as instance data are copied.
		 Object.keys(setting).forEach(function(val) {
			if ( val === "use_level" )
			  val = "_use_level"
			this[val] = setting[val]
		 }, this)
	  }

	   // void is used the same as the parenthesis enclosure method to make functions callable in the declaration. It returns the function declaration 
		// to void which returns it to the command line. Without void something else in the expression evaluation of the function is returned to the 
		// command line (which returns undefined).
	void function parse_args(args) {
		// This is called recursively on a arguments Object so that an arguments Objects inside of the arguments Object are also parsed. This is how
		// arguments as arguments are also accepted by the callee.

		 for ( var x = 0; x < args.length; x++ ) {
			if ( args[x] instanceof Print ) {
			  copy_setting.call(this, Object.keys(args[x].list()))
			} else if ( Object.prototype.toString.call(args[x]) === "[object Arguments]" ) {
			  parse_args.call(this, args[x])
			} else {
			  // This tells the set_option that it is already a fresh root copy of Print and to not make another one (it is used internally).
			  this._from_constructor = true
			  this.set_option(args[x])
			}
		 }
	  }.call(this, arguments)

	  this._old_platform = this.platform
	  this._last_command = null
	  this._output = ""
	  this._styleless_output = ""
	  this._cache = []
	  this._is_from_object = false
	  this.apply_arguments = []
	  this.formated = ""
	  this.plain = ""
	  //this.platform_index = [] 
	  this.plain_index = []
	  this.formated_index = []
	  // This may be included when another Print instance is passed into this constructor for a settings copy.
	}

	// These options are created one level deep (__proto__), in the Print() prototype chain. All of these options are user configurable
	// within the library but these properties (at this level), are only used as defaults sense there is no way to change them with the library api
	// (Print().__proto__ is the only way). If the prototype is set (e.g. Print.prototype.level = 3), ir the instance data, it will be used
	// instead of these values. A call to delete a property will also revert it back to the default value, e.g. Print.prototype.level and.or
	// Print().level will revert the level option back to the default value (from below).
	obj.parent = Print
	Print.prototype = obj
	//Print.prototype.parent = Print
	obj.style_map = style_map

	obj.remove_call = function() {
	  // This member removes all of the text added to the internal buffer created by calls the style map. The text is indexed by every call that is made
	  // to the style mapping member and thusly can be removed from the buffer. This mechanism works like the Array.splice member and also returns the
	  // removed call text. The console.log mechanism in gecko based browsers use printf like format with style styles so a separate Array is created
	  // to store them and passed to console.log via an apply.
		
		var uses_apply = this.style_map[this.platform].format.length >= 3
		if ( uses_apply )
			this.apply_arguments.splice.apply(this.apply_arguments, arguments)

	  var formated_index = this.formated_index.splice.apply(this.formated_index, arguments)[0] || 0
	  var plain_index = this.plain_index.splice.apply(this.plain_index, arguments)[0] || 0
	  // This is the text data which is removed
	  var removed = {formated: this.formated.substr(formated_index), plain: this.plain.substr(plain_index) }

	  // This is the internal buffer text which is now truncated.
	  this.formated = this.formated.substr(0, formated_index)
	  this.plain = this.plain.substr(0, plain_index)

	  return removed
	}

	obj.append_string = function(style_name, str) {
		if ( this.plain.length === this.character_limit )
			return this

		var plain = str && str.toString() || ""
		// TODO: Adding line breaks for max screen width control may be a nifty feature here.
		var truncated_msg = ".. Object truncated"
		truncated_msg = this.character_limit > (truncated_msg.length*3) && truncated_msg || ""
		if ( this.plain.length + plain.length > this.character_limit - truncated_msg.length )
			plain = plain.substr(0, this.character_limit - this.plain.length - truncated_msg.length ) + truncated_msg

		this.plain_index.push(this.plain.length)
		this.plain += plain

		if ( this.use_style ) {
			var theme = "", uses_apply = this.style_map[this.platform].format.length >= 3, platform = this.style_map[this.platform].use_theme || this.platform
			this.formated_index.push(this.formated.length)
			// The regex test will prevent stylization of values which do not contain a visible character.
			if ( this.style_map[platform][this.theme+"_level_"+this.level] ) {
				theme = this.theme+"_level_"+this.level
			} else {
				theme = Object.keys(this.style_map[platform].theme)[0]
			}
			if ( !theme ) 
				// Return the instance by using log_true so that the && will always test and return the this.
				return this.parent({theme: this.theme+"_internal", level: this.internal_level, title: "Bracket Print Error"})
					.log_true("The requested theme", theme, "is not included.") && this
			

			// Use the value from the style map type (example: quote, number), or use the first available one.
			var style_value = style_name in this.style_map[platform].theme[theme] || Object.keys(this.style_map[platform].theme[theme])[0]

			if ( !style_value )
				// This only happens when the style theme Object contains no properties.
				return this.parent({theme: this.theme+"_internal", level: this.internal_level, title: "Bracket Print Error"})
					.log_true("There is not any style data set in the theme", theme, "for the platform", this.platform) && this

			this.formated += this.style_map[this.platform].format(style_value, plain, uses_apply && this.apply_arguments || null)
		}

		return this
	}

	return Print

})


;
n.i.length && define([ n.i ], function(e) {
        return e;
    });
}(this, "function" == typeof define && define || void 0, "function" == typeof requirejs && requirejs || void 0,{"auto_anonymous":true});
